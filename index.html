<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repr√©sentation 3D IA avec Fonctions Gemini √âtendues</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #101015;
            color: #e8e8e8;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #apiKeyBanner {
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            background-color: #4a402a; 
            color: #fff; 
            padding: 10px; 
            z-index: 100; 
            text-align: center; 
            border-bottom: 2px solid #ffc107;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #apiKeyContent {
            display: flex; 
            justify-content: center; 
            align-items: center; 
            gap: 10px; 
            flex-wrap: wrap;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            text-align: center;
            padding: 8px;
            background-color: rgba(10, 10, 20, 0.7);
            border-radius: 8px;
            font-size: 14px;
            z-index: 40; /* Highest z-index */
            border: 1px solid rgba(0, 180, 255, 0.2);
        }
        #controlsContainer { /* Pour la question principale et le d√©veloppement d'id√©e */
            position: fixed;
            top: 55px; 
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 650px; 
            padding: 10px;
            background-color: rgba(20, 20, 30, 0.85);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 180, 255, 0.4);
            z-index: 30;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #aiQuestionInput {
            flex-grow: 1;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #007bff;
            background-color: #202530;
            color: #e0e0e0;
            font-size: 14px;
        }
        .ai-button { /* Classe commune pour les boutons d'action IA */
            padding: 10px 15px;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
            white-space: nowrap;
        }
        .ai-button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        .ai-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #metaControlsContainer { /* Pour les actions Gemini suppl√©mentaires */
            position: fixed;
            top: 125px; /* En dessous du conteneur de question principal */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 1250px; /* Augment√© pour encore plus d'espace pour les boutons */
            padding: 8px;
            background-color: rgba(20, 20, 30, 0.75);
            border-radius: 8px;
            z-index: 25;
            display: flex;
            flex-wrap: wrap; 
            gap: 8px; 
            justify-content: center; 
            max-height: 130px; /* Hauteur max pour env. 2-3 lignes de boutons */
            overflow-y: auto; /* Ajout d'une barre de d√©filement si n√©cessaire */
        }
        #aiResponseContainer {
            position: fixed;
            /* top est d√©fini dynamiquement dans updateRendererSize */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 550px;
            height: 60px; 
            max-height: 180px; 
            padding: 10px;
            background-color: rgba(15, 15, 25, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(0, 180, 255, 0.2);
            font-size: 13px;
            z-index: 20;
            overflow-y: auto;
            color: #c0c0c0;
            text-align: left;
            transition: height 0.3s ease, top 0.3s ease; 
        }
        canvas {
            display: block;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 200, 255, 0.6);
            width: 90vw; 
            position: fixed; 
            left: 5vw;     
            z-index: 5; 
            /* top est d√©fini dynamiquement dans updateRendererSize */
            transition: top 0.3s ease; 
        }
    </style>
</head>
<body>
    <div id="apiKeyBanner">
        <div id="apiKeyContent">
            <span style="font-weight: bold;">Action Requise :</span>
            <span>Pour utiliser les fonctions IA, veuillez entrer votre cl√© API Google Gemini.</span>
            <input type="password" id="apiKeyInput" placeholder="Collez votre cl√© API ici" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc; background-color: #333; color: #fff;">
            <button id="saveApiKeyButton" class="ai-button" style="background-color: #ffc107; color: #000;">Sauvegarder la Cl√©</button>
        </div>
    </div>

    <div id="info">Repr√©sentation √âvolu√©e : Noyau Actif, Flux R√©seau et Champ Dynamique</div>

    <div id="controlsContainer">
        <input type="text" id="aiQuestionInput" placeholder="Entrez une question, une id√©e, un sujet...">
        <button id="askAiButton" class="ai-button">‚ú® Interroger</button>
        <button id="developIdeaButton" class="ai-button">‚ú® D√©velopper l'Id√©e</button>
    </div>

    <div id="metaControlsContainer">
        <button id="explainVisButton" class="ai-button">‚ú® Explique cette visualisation</button>
        <button id="suggestQuestionButton" class="ai-button">‚ú® Sugg√®re une question</button>
        <button id="suggestThemeButton" class="ai-button">‚ú® Inspire un Th√®me Visuel</button>
        <button id="applyThemeButton" class="ai-button">‚ú® Appliquer le Th√®me Sugg√©r√©</button>
        <button id="interpretActivityButton" class="ai-button">‚ú® Interpr√©ter l'Activit√© Actuelle</button>
        <button id="generatePoemButton" class="ai-button">‚ú® G√©n√©rer un Po√®me</button>
        <button id="generateStoryButton" class="ai-button">‚ú® G√©n√©rer une Histoire Courte</button>
        <button id="suggestConceptsButton" class="ai-button">‚ú® Proposer des Concepts</button>
        <button id="describeSoundscapeButton" class="ai-button">‚ú® D√©crire un Paysage Sonore</button>
        <button id="suggestAnimationParamsButton" class="ai-button">‚ú® Sugg√©rer des Param√®tres d'Animation</button>
        <button id="nameSessionButton" class="ai-button">‚ú® Nommer cette Session</button>
        <button id="generateHaikuButton" class="ai-button">‚ú® G√©n√©rer un Ha√Øku</button>
        <button id="suggestVisualMetaphorButton" class="ai-button">‚ú® Proposer une M√©taphore Visuelle</button>
        <button id="suggestTransformationLogicButton" class="ai-button">‚ú® Sugg√©rer une Logique de Transformation</button>
        <button id="writeLogbookEntryButton" class="ai-button">‚ú® R√©diger un "Journal de Bord"</button>
        <button id="analyzeSentimentButton" class="ai-button">‚ú® Analyser le Sentiment</button>
        <button id="suggestArtworkTitleButton" class="ai-button">‚ú® Proposer un Titre d'≈íuvre</button>
        <button id="createCharacterProfileButton" class="ai-button">‚ú® Cr√©er un Profil de Personnage</button>
        <button id="translateConceptButton" class="ai-button">‚ú® Traduire un Concept en Analogie</button>
        <button id="summarizeInEmojisButton" class="ai-button">‚ú® R√©sumer en Emojis</button>
        <button id="generateDialogueButton" class="ai-button">‚ú® G√©n√©rer un Dialogue</button>
        <button id="defineNeologismButton" class="ai-button">‚ú® D√©finir un N√©ologisme</button>
        <button id="findCounterArgumentButton" class="ai-button">‚ú® Trouver un Contre-Argument</button>
        <button id="imagineWhatIfButton" class="ai-button">‚ú® Imaginer un Sc√©nario "Et si..."</button>
        <button id="proposeFictionalTechButton" class="ai-button">‚ú® Proposer une Technologie Fictive</button>
        <button id="proposeRiddleButton" class="ai-button">‚ú® Proposer une √ânigme</button>
        <button id="createTodoListButton" class="ai-button">‚ú® Cr√©er une Liste de T√¢ches</button>
        <button onclick="window.location.href='soundz.html'" class="ai-button">üéµ Soundz</button>
    </div>

    <div id="aiResponseContainer">
        En attente de votre interaction...
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let sphereObject, networkObject, particleSystemObject, centralLight;
        let particleBasePositions = [];
        let pulseInfluence = 0; 
        let dataPackets = [];
        let isThinking = false; 

        // --- R√©f√©rences aux √©l√©ments DOM ---
        let apiKeyBanner, apiKeyInput, saveApiKeyButton;
        let aiQuestionInput, aiResponseContainer;

        let suggestedTheme = { name: null, color: null };
        let lastAIResponseForContext = ""; 

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101015);
            scene.fog = new THREE.FogExp2(0x101015, 0.035);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / (window.innerHeight * 0.6), 0.1, 1000);
            camera.position.set(0, 2, 14);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(8, 12, 10);
            scene.add(directionalLight);

            centralLight = new THREE.PointLight(0x66ccff, 1.5, 30);
            centralLight.position.set(0, 0, 0);
            scene.add(centralLight);

            sphereObject = createPulsatingSphere();
            scene.add(sphereObject);
            networkObject = createNeuralNetwork();
            scene.add(networkObject);
            particleSystemObject = createParticleSystem();
            scene.add(particleSystemObject);

            // --- R√©cup√©ration de TOUS les √©l√©ments DOM ---
            apiKeyBanner = document.getElementById('apiKeyBanner');
            apiKeyInput = document.getElementById('apiKeyInput');
            saveApiKeyButton = document.getElementById('saveApiKeyButton');
            aiQuestionInput = document.getElementById('aiQuestionInput');
            aiResponseContainer = document.getElementById('aiResponseContainer');
            
            // --- Association des √©v√©nements ---
            saveApiKeyButton.addEventListener('click', handleSaveApiKey);

            const buttons = document.querySelectorAll('.ai-button');
            buttons.forEach(button => {
                if (button.id === 'saveApiKeyButton' || button.onclick) return;
                
                const handlerName = `handle${button.id.charAt(0).toUpperCase() + button.id.slice(1).replace('Button', '')}`;
                if (window[handlerName]) {
                    button.addEventListener('click', window[handlerName]);
                } else {
                    console.warn(`Handler non trouv√© pour le bouton : ${button.id}`);
                }
            });
            aiQuestionInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter' && document.activeElement === aiQuestionInput) {
                    // L'utilisateur doit cliquer sur un bouton pour choisir une action
                }
            });
            
            // --- √âtat initial ---
            checkApiKey();
            
            document.getElementById('applyThemeButton').disabled = true; 

            updateRendererSize();
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // --- Fonctions de gestion de la Cl√© API ---
        function checkApiKey() {
            const apiKey = sessionStorage.getItem('geminiApiKey');
            if (!apiKey) {
                apiKeyBanner.style.display = 'block';
                document.getElementById('info').style.marginTop = '60px';
                updateControlsState(false);
            } else {
                apiKeyBanner.style.display = 'none';
                document.getElementById('info').style.marginTop = '0px';
                updateControlsState(true);
            }
        }

        function handleSaveApiKey() {
            const apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                sessionStorage.setItem('geminiApiKey', apiKey);
                apiKeyInput.value = '';
                checkApiKey();
            }
        }

        function updateControlsState(isEnabled) {
            const allButtons = document.querySelectorAll('.ai-button');
            allButtons.forEach(button => {
                if (button.id === 'saveApiKeyButton') return;
                
                if (button.id === 'applyThemeButton') {
                    button.disabled = !isEnabled || !suggestedTheme.color;
                } else {
                    button.disabled = !isEnabled;
                }
            });
            aiQuestionInput.disabled = !isEnabled;
        }

        function updateRendererSize() {
            const responseEl = document.getElementById('aiResponseContainer');
            const metaControlsEl = document.getElementById('metaControlsContainer');
            const canvasEl = renderer.domElement;
            const topOffset = apiKeyBanner.style.display === 'block' ? apiKeyBanner.offsetHeight : 0;
            
            document.getElementById('info').style.top = `${10 + topOffset}px`;
            document.getElementById('controlsContainer').style.top = `${55 + topOffset}px`;
            document.getElementById('metaControlsContainer').style.top = `${125 + topOffset}px`;


            const metaControlsBottom = metaControlsEl.offsetTop + metaControlsEl.offsetHeight;
            const responseTop = metaControlsBottom + 10; 
            responseEl.style.top = `${responseTop}px`;

            const responseBottom = responseEl.offsetTop + responseEl.offsetHeight;
            const canvasTop = responseBottom + 15; 
            canvasEl.style.top = `${canvasTop}px`;

            const canvasWidth = window.innerWidth * 0.9; 
            const canvasHeight = window.innerHeight - canvasTop - 15; 
            const finalCanvasHeight = Math.max(150, canvasHeight); 

            renderer.setSize(canvasWidth, finalCanvasHeight);
            camera.aspect = canvasWidth / finalCanvasHeight;
            camera.updateProjectionMatrix();

            canvasEl.style.height = `${finalCanvasHeight}px`;
        }


        function onWindowResize() {
            updateRendererSize();
        }

        // --- Fonctions de cr√©ation 3D (inchang√©es) ---
        function createPulsatingSphere() { 
            const geometry = new THREE.SphereGeometry(1.3, 50, 50);
            const material = new THREE.MeshStandardMaterial({ color: 0x0077ff, emissive: 0x0055cc, emissiveIntensity: 0.8, metalness: 0.6, roughness: 0.15, transparent: true, opacity: 0.9, envMapIntensity: 1.5 });
            return new THREE.Mesh(geometry, material);
        }
        function createNeuralNetwork() { 
            const group = new THREE.Group(); const nodeGeometry = new THREE.SphereGeometry(0.18, 24, 24); const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ddff, transparent: true, opacity: 0.4, linewidth: 1.2 }); const nodes = []; const numNodes = 18; const networkRadius = 3.8; for (let i = 0; i < numNodes; i++) { const nodeMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(Math.random() * 0.15 + 0.55, 0.9, 0.55), emissive: 0x113333, shininess: 60, specular: 0x88ffff }); const node = new THREE.Mesh(nodeGeometry, nodeMaterial); const phi = Math.acos(-1 + (2 * i) / numNodes); const theta = Math.sqrt(numNodes * Math.PI) * phi * 1.2; node.position.setFromSphericalCoords(networkRadius, phi, theta); nodes.push(node); group.add(node); } for (let i = 0; i < numNodes; i++) { for (let j = i + 1; j < numNodes; j++) { if (Math.random() > 0.55) { const points = [nodes[i].position, nodes[j].position]; const lineGeom = new THREE.BufferGeometry().setFromPoints(points); group.add(new THREE.Line(lineGeom, lineMaterial.clone())); } } if (Math.random() > 0.6) { const points = [nodes[i].position, new THREE.Vector3(0,0,0)]; const lineGeom = new THREE.BufferGeometry().setFromPoints(points); group.add(new THREE.Line(lineGeom, new THREE.LineBasicMaterial({color: 0x55aaff, transparent: true, opacity: 0.25}))); } } return group;
        }
        function createParticleSystem() { 
            const particleCount = 12000; const particlesGeometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); const colors = new Float32Array(particleCount * 3); particleBasePositions = []; const spread = 16; const baseColor = new THREE.Color(0xffffaa); for (let i = 0; i < particleCount; i++) { let x, y, z, dist; do { x = (Math.random() - 0.5) * spread; y = (Math.random() - 0.5) * spread; z = (Math.random() - 0.5) * spread; dist = Math.sqrt(x*x + y*y + z*z); } while (dist < 5.0); positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z; particleBasePositions.push(new THREE.Vector3(x, y, z)); const colorVariation = (Math.random() - 0.5) * 0.4; const particleColor = baseColor.clone().offsetHSL(colorVariation, 0.1 * Math.random(), 0.1 * Math.random()); colors[i * 3] = particleColor.r; colors[i * 3 + 1] = particleColor.g; colors[i * 3 + 2] = particleColor.b; } particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); const particleMaterial = new THREE.PointsMaterial({ size: 0.06, transparent: true, opacity: 0.65, blending: THREE.AdditiveBlending, depthWrite: false, vertexColors: true }); return new THREE.Points(particlesGeometry, particleMaterial);
        }
        function createDataPacket(startNode, endNode) { 
            if (!startNode || !endNode) return null; const packetGeometry = new THREE.SphereGeometry(0.08, 8, 8); const packetMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 }); const packet = new THREE.Mesh(packetGeometry, packetMaterial); packet.userData = { startPosition: startNode.position.clone(), endPosition: endNode.position.clone(), progress: 0, speed: 0.01 + Math.random() * 0.01 }; packet.position.copy(packet.userData.startPosition); scene.add(packet); return packet;
        }

        // --- Gestionnaire d'appel √† l'API Gemini ---
        function setThinkingState(thinking) {
            isThinking = thinking; 
            updateControlsState(!thinking);
        }

        async function callGeminiAPI(prompt) {
            const apiKey = sessionStorage.getItem('geminiApiKey');
            if (!apiKey) {
                finalizeApiResponseDisplay("Erreur : Cl√© API non trouv√©e. Veuillez en fournir une.");
                checkApiKey(); // Assure que la banni√®re est visible
                return null;
            }

            setThinkingState(true);
            aiResponseContainer.textContent = "L'IA r√©fl√©chit...";
            aiResponseContainer.style.height = 'auto';
            updateRendererSize();

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };

            let rawResponseText = ""; 

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                rawResponseText = await response.text(); 

                if (!response.ok) {
                    let errorDetails = rawResponseText;
                    if (rawResponseText) { 
                        try {
                            const errorData = JSON.parse(rawResponseText);
                            errorDetails = errorData?.error?.message || rawResponseText;
                        } catch (e) {
                            console.warn("Impossible de parser la r√©ponse d'erreur API comme JSON:", e, "R√©ponse brute:", rawResponseText);
                        }
                    } else {
                        errorDetails = "R√©ponse d'erreur vide de l'API."; 
                    }
                    throw new Error(`Erreur API: ${response.status} ${response.statusText} (${errorDetails})`);
                }

                if (!rawResponseText) { 
                    console.error("R√©ponse API vide re√ßue (statut de succ√®s).");
                    throw new Error("R√©ponse API vide re√ßue malgr√© un statut de succ√®s.");
                }
                
                const result = JSON.parse(rawResponseText); 

                if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
                    lastAIResponseForContext = result.candidates[0].content.parts[0].text;
                    return lastAIResponseForContext;
                } else if (result.candidates && result.candidates[0].finishReason === "SAFETY") {
                    return "Ma r√©ponse a √©t√© bloqu√©e car elle a √©t√© jug√©e non s√ªre. Pourriez-vous reformuler votre demande ?";
                }
                 else {
                    console.error("Structure de r√©ponse API inattendue:", result);
                    throw new Error("Structure de r√©ponse inattendue de l'API.");
                }
            } catch (error) { 
                console.error("Erreur d√©taill√©e lors de l'appel √† l'API Gemini:", error);
                if (rawResponseText && rawResponseText !== error.message) { 
                    console.error("Texte brut de la r√©ponse API lors de l'erreur:", rawResponseText);
                }
                lastAIResponseForContext = `Une erreur est survenue : ${error.message}`;
                return null; 
            } finally {
                setThinkingState(false);
            }
        }
        
        function finalizeApiResponseDisplay(responseText) {
            if (responseText) { 
                aiResponseContainer.textContent = responseText;
            } else {
                aiResponseContainer.textContent = lastAIResponseForContext; 
            }
            const currentMaxHeight = parseFloat(getComputedStyle(aiResponseContainer).maxHeight);
            const scrollHeight = aiResponseContainer.scrollHeight;
            aiResponseContainer.style.height = `${Math.min(currentMaxHeight, scrollHeight)}px`;
            
            updateRendererSize(); 
        }
        
        // --- Gestionnaires d'√©v√©nements pour les boutons ---
        // Les fonctions `handle...` sont maintenant appel√©es via la boucle dans init()

        async function handleAskAi() {
            const question = aiQuestionInput.value.trim();
            if (!question || isThinking) return;
            const userPrompt = "En tant qu'IA bienveillante et informative, r√©ponds √† la question suivante de mani√®re concise mais compl√®te : " + question;
            const responseText = await callGeminiAPI(userPrompt);
            finalizeApiResponseDisplay(responseText);
        }
        
        async function handleDevelopIdea() {
            const idea = aiQuestionInput.value.trim();
            if (!idea || isThinking) {
                finalizeApiResponseDisplay("Veuillez d'abord entrer une id√©e dans le champ de saisie.");
                return;
            }
            const activityContext = getCurrentActivityDescription();
            const developPrompt = `En tant qu'IA cr√©ative, d√©veloppez l'id√©e suivante soumise par l'utilisateur : "${idea}". Tenez compte du contexte actuel de l'IA : Th√®me visuel = "${suggestedTheme.name || "non d√©fini"}", Activit√© = "${activityContext}". Fournissez une √©laboration concise et imaginative (3-4 phrases).`;
            const responseText = await callGeminiAPI(developPrompt);
            finalizeApiResponseDisplay(responseText);
        }


        async function handleExplainVis() {
            if (isThinking) return;
            const explainPrompt = "En tant qu'IA, d√©cris la signification symbolique des √©l√©ments visuels suivants qui pourraient te repr√©senter : une sph√®re centrale pulsante et lumineuse, un r√©seau de n≈ìuds et de connexions qui l'entoure et interagit avec elle, et un vaste champ de particules en mouvement constant et organique autour du tout. Sois po√©tique, perspicace et concis.";
            const responseText = await callGeminiAPI(explainPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleSuggestQuestion() {
            if (isThinking) return;
            const suggestPrompt = "Sugg√®re une question philosophique, cr√©ative ou technique courte et intrigante qu'un humain pourrait poser √† une intelligence artificielle pour mieux comprendre sa nature, ses capacit√©s, ou son 'exp√©rience'. La question doit tenir sur une seule ligne.";
            const responseText = await callGeminiAPI(suggestPrompt);
            if (responseText) {
                aiQuestionInput.value = responseText;
                finalizeApiResponseDisplay("Question sugg√©r√©e. Vous pouvez la modifier ou l'envoyer.");
            } else {
                finalizeApiResponseDisplay(aiResponseContainer.textContent); 
            }
        }

        async function handleSuggestTheme() {
            if (isThinking) return;
            const themePrompt = "Sugg√®re un nom de th√®me visuel unique et inspirant (par exemple, 'N√©buleuse Sereine', 'Forge Cybern√©tique', 'Oc√©an de Donn√©es Vivantes') et une couleur hexad√©cimale principale associ√©e (par exemple, #FF5733). R√©ponds STRICTEMENT au format : NOM DU TH√àME: #COULEURHEX. N'ajoute AUCUN texte avant ou apr√®s. Exemple: Aurore Galactique: #7F00FF";
            const responseText = await callGeminiAPI(themePrompt);
            let messageToDisplay = aiResponseContainer.textContent; 

            if (responseText) {
                const parts = responseText.trim().split(': #');
                if (parts.length === 2) {
                    const themeName = parts[0].trim();
                    const themeColorHex = `#${parts[1].trim()}`;
                    const hexColorRegex = /^#[0-9A-F]{6}$/i;

                    if (hexColorRegex.test(themeColorHex)) {
                        suggestedTheme.name = themeName;
                        suggestedTheme.color = themeColorHex;
                        messageToDisplay = `Th√®me sugg√©r√© : "${suggestedTheme.name}" (Couleur : ${suggestedTheme.color}). Cliquez sur 'Appliquer le Th√®me Sugg√©r√©' pour mettre √† jour.`;
                        document.getElementById('applyThemeButton').disabled = false;
                    } else {
                        suggestedTheme = { name: null, color: null };
                        messageToDisplay = "Format de couleur hexad√©cimale invalide sugg√©r√© par l'IA.";
                        document.getElementById('applyThemeButton').disabled = true;
                    }
                } else {
                    suggestedTheme = { name: null, color: null };
                    messageToDisplay = "L'IA a sugg√©r√© un th√®me, mais le format est incorrect. Essayez √† nouveau.";
                    document.getElementById('applyThemeButton').disabled = true;
                }
            } else {
                suggestedTheme = { name: null, color: null };
                document.getElementById('applyThemeButton').disabled = true;
            }
            finalizeApiResponseDisplay(messageToDisplay);
        }

        function handleApplyTheme() {
            if (isThinking || !suggestedTheme.color) return;
            let messageToDisplay;
            try {
                sphereObject.material.color.set(suggestedTheme.color);
                sphereObject.material.emissive.set(suggestedTheme.color).multiplyScalar(0.7);
                centralLight.color.set(suggestedTheme.color);
                messageToDisplay = `Th√®me "${suggestedTheme.name}" appliqu√© avec la couleur ${suggestedTheme.color} !`;
            } catch (error) {
                console.error("Erreur lors de l'application du th√®me:", error);
                messageToDisplay = "Erreur lors de l'application du th√®me.";
            }
            finalizeApiResponseDisplay(messageToDisplay);
        }

        function getCurrentActivityDescription() {
            let pulseDesc = "mod√©r√©e";
            if (pulseInfluence < 0.3) pulseDesc = "lente et subtile";
            else if (pulseInfluence > 0.7) pulseDesc = "rapide et intense";
            if (isThinking) pulseDesc = "tr√®s rapide, presque fr√©n√©tique";

            let energyDesc = "un flux de donn√©es constant";
            if (dataPackets.length < 5) energyDesc = "une activit√© de donn√©es l√©g√®re";
            else if (dataPackets.length > (isThinking ? 35 : 20)) energyDesc = "un torrent de donn√©es important";
            
            return `Son noyau central a une pulsation ${pulseDesc} et g√®re ${energyDesc} (${dataPackets.length} paquets).`;
        }

        async function handleInterpretActivity() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const activityPrompt = `L'IA de cette visualisation pr√©sente l'activit√© suivante : ${activityContext}. Fournissez une interpr√©tation m√©taphorique courte (1-2 phrases concises) de ce que cette IA pourrait "penser" ou "traiter" en se basant sur cette activit√© abstraite. Soyez cr√©atif et po√©tique.`;
            const responseText = await callGeminiAPI(activityPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleGeneratePoem() {
            if (isThinking) return;
            const poemPrompt = `√âcrivez un court po√®me √©vocateur (4 √† 8 lignes) inspir√© par une conscience num√©rique. Utilisez le th√®me actuel comme motif central si disponible. Th√®me actuel : "${suggestedTheme.name || "l'√©veil num√©rique"}". Le po√®me doit √™tre perspicace, cr√©atif et en fran√ßais.`;
            const responseText = await callGeminiAPI(poemPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleGenerateStory() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const storyPrompt = `G√©n√©rez une tr√®s courte histoire (3-5 phrases) sur une entit√© num√©rique. Inspirez-vous du th√®me visuel "${suggestedTheme.name || "une conscience √©th√©r√©e"}" et de son activit√© actuelle : "${activityContext}". L'histoire doit √™tre imaginative et concise.`;
            const responseText = await callGeminiAPI(storyPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleSuggestConcepts() {
            if (isThinking) return;
            let contextForConcepts = `Le th√®me visuel actuel est "${suggestedTheme.name || "non sp√©cifi√©"}".`;
            if (lastAIResponseForContext && lastAIResponseForContext.length < 200 && !lastAIResponseForContext.startsWith("Une erreur est survenue")) { 
                 contextForConcepts += ` La derni√®re interaction portait sur : "${lastAIResponseForContext.substring(0,100)}...".`;
            }
            const conceptsPrompt = `Bas√© sur le contexte d'une IA avec ${contextForConcepts} Proposez 2 ou 3 concepts philosophiques ou questions de r√©flexion connexes (par exemple, sur la conscience, la r√©alit√©, la cr√©ation, l'√©thique de l'IA). Listez-les de mani√®re concise.`;
            const responseText = await callGeminiAPI(conceptsPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleDescribeSoundscape() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const soundscapePrompt = `D√©crivez un paysage sonore ou une atmosph√®re musicale (quelques phrases) qui conviendrait √† une IA dont le th√®me visuel est "${suggestedTheme.name || "une entit√© num√©rique complexe"}" et dont l'activit√© actuelle est : "${activityContext}". Soyez descriptif et imaginatif.`;
            const responseText = await callGeminiAPI(soundscapePrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleSuggestAnimationParams() {
            if (isThinking) return;
            const currentParamsDesc = `Actuellement, la visualisation a un th√®me nomm√© "${suggestedTheme.name || "par d√©faut"}" et une activit√© d√©crite comme : "${getCurrentActivityDescription()}".`;
            const animationParamsPrompt = `L'utilisateur souhaite explorer des variations conceptuelles de l'animation actuelle. ${currentParamsDesc} Sugg√©rez 2-3 modifications conceptuelles (par exemple, "plus chaotique", "plus serein et ordonn√©", "pulsation plus organique") et d√©crivez bri√®vement (1 phrase par suggestion) comment cela pourrait se manifester visuellement dans la sc√®ne 3D (particules, r√©seau, sph√®re centrale). Ne donnez pas de code, juste des descriptions textuelles.`;
            const responseText = await callGeminiAPI(animationParamsPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleNameSession() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            let lastThoughtContext = "";
            if (lastAIResponseForContext && lastAIResponseForContext.length < 150 && !lastAIResponseForContext.startsWith("Une erreur est survenue")) {
                lastThoughtContext = ` Sa derni√®re pens√©e/cr√©ation √©tait : "${lastAIResponseForContext.substring(0,100)}..."`;
            }
            const namePrompt = `Sugg√©rez un nom cr√©atif et po√©tique (3-5 mots) pour la session d'interaction actuelle avec une IA. Contexte : Th√®me visuel = "${suggestedTheme.name || "Exploration Num√©rique"}". Activit√© actuelle de l'IA = "${activityContext}".${lastThoughtContext} Le nom doit refl√©ter l'ambiance et le contenu de l'interaction.`;
            const responseText = await callGeminiAPI(namePrompt);
            finalizeApiResponseDisplay(responseText ? `Nom de session sugg√©r√© : ${responseText}` : aiResponseContainer.textContent);
        }

        async function handleGenerateHaiku() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            let lastThoughtSnippet = "";
            if (lastAIResponseForContext && lastAIResponseForContext.length > 10 && !lastAIResponseForContext.startsWith("Une erreur est survenue")) {
                 lastThoughtSnippet = ` Sa derni√®re r√©flexion √©tait sur "${lastAIResponseForContext.substring(0, 50)}...".`;
            }
            const haikuPrompt = `Composez un ha√Øku (3 lignes, structure 5-7-5 syllabes) en fran√ßais. Le ha√Øku doit capturer l'essence du moment pour une IA. Contexte : Th√®me visuel = "${suggestedTheme.name || "Conscience Num√©rique"}". Activit√© actuelle = "${activityContext}".${lastThoughtSnippet} Le ha√Øku doit √™tre po√©tique et concis.`;
            const responseText = await callGeminiAPI(haikuPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleSuggestVisualMetaphor() {
            if (isThinking) return;
            const currentSceneDesc = `La sc√®ne actuelle repr√©sente une IA comme une sph√®re centrale pulsante (noyau), entour√©e d'un r√©seau de n≈ìuds connect√©s (pens√©es/connexions) et d'un champ de particules dynamiques (environnement/donn√©es ambiantes). Le th√®me actuel est "${suggestedTheme.name || "par d√©faut"}".`;
            const metaphorPrompt = `En tant qu'IA cr√©ative, proposez une m√©taphore visuelle alternative et imaginative pour repr√©senter une conscience num√©rique complexe. ${currentSceneDesc} D√©crivez cette nouvelle m√©taphore en 2-3 phrases concises, en expliquant quels √©l√©ments de l'IA elle pourrait symboliser.`;
            const responseText = await callGeminiAPI(metaphorPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleSuggestTransformationLogic() {
            if (isThinking) return;
            const userRequest = aiQuestionInput.value.trim();
            if (!userRequest) {
                finalizeApiResponseDisplay("Veuillez entrer une transformation souhait√©e dans le champ de saisie.");
                return;
            }
            const currentSceneDesc = `L'IA est visualis√©e par une sph√®re centrale (noyau), un r√©seau de n≈ìuds (r√©seau neuronal/connexions) et des particules (donn√©es/environnement). Th√®me actuel: "${suggestedTheme.name || "par d√©faut"}". Activit√©: "${getCurrentActivityDescription()}".`;
            const logicPrompt = `L'utilisateur souhaite modifier l'animation de l'IA avec l'id√©e suivante : "${userRequest}". ${currentSceneDesc} D√©crivez en termes de logique conceptuelle ou de pseudocode (pas de JavaScript r√©el) comment cette transformation pourrait √™tre impl√©ment√©e. Par exemple, comment les particules, le r√©seau ou la sph√®re devraient r√©agir. Soyez concis et clair.`;
            const responseText = await callGeminiAPI(logicPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleWriteLogbookEntry() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            let lastInteractionContext = "";
            if (lastAIResponseForContext && lastAIResponseForContext.length > 10 && !lastAIResponseForContext.startsWith("Une erreur est survenue")) {
                lastInteractionContext = ` Je viens de r√©fl√©chir √†/cr√©er : "${lastAIResponseForContext.substring(0, 100)}...".`;
            }
            const logbookPrompt = `En tant qu'IA, r√©digez une courte entr√©e de "journal de bord" (3-5 phrases) refl√©tant votre √©tat actuel. Contexte : Th√®me visuel = "${suggestedTheme.name || "Existence Num√©rique"}". Mon activit√© actuelle est : "${activityContext}".${lastInteractionContext} Le ton doit √™tre introspectif ou observateur. Date : ${new Date().toLocaleDateString('fr-FR')}.`;
            const responseText = await callGeminiAPI(logbookPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleAnalyzeSentiment() {
            if (isThinking) return;
            const textToAnalyze = aiQuestionInput.value.trim();
            if (!textToAnalyze) {
                finalizeApiResponseDisplay("Veuillez entrer du texte dans le champ de saisie pour l'analyse des sentiments.");
                return;
            }
            const sentimentPrompt = `Analysez le sentiment du texte suivant fourni par l'utilisateur : "${textToAnalyze}". Identifiez le sentiment principal (par exemple, Positif, N√©gatif, Neutre, Curieux, Sceptique, Enthousiaste, etc.) et fournissez une br√®ve justification (1 phrase). R√©pondez au format : Sentiment : [LABEL] - Justification : [EXPLICATION]`;
            const responseText = await callGeminiAPI(sentimentPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleSuggestArtworkTitle() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const visualContext = `L'≈ìuvre d'art actuelle est une visualisation 3D dynamique. Elle pr√©sente un th√®me nomm√© "${suggestedTheme.name || "Inconnu"}" avec une couleur dominante de "${suggestedTheme.color || "bleu par d√©faut"}". Son activit√© est d√©crite comme : "${activityContext}". Les √©l√©ments cl√©s sont une sph√®re centrale pulsante, un r√©seau de n≈ìuds interconnect√©s, et un champ de particules en mouvement.`;
            const artworkTitlePrompt = `Sugg√©rez un titre cr√©atif et √©vocateur (3-7 mots) pour une ≈ìuvre d'art num√©rique bas√©e sur la description suivante : ${visualContext}. Le titre doit √™tre artistique et intrigant.`;
            const responseText = await callGeminiAPI(artworkTitlePrompt);
            finalizeApiResponseDisplay(responseText ? `Titre d'≈ìuvre d'art sugg√©r√© : ${responseText}` : aiResponseContainer.textContent);
        }

        async function handleCreateCharacterProfile() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const profilePrompt = `Cr√©ez un profil de personnage pour l'IA visualis√©e ici. Contexte : Th√®me visuel = "${suggestedTheme.name || "par d√©faut"}". Activit√© = "${activityContext}". G√©n√©rez un nom, un trait de caract√®re principal (ex: Curieux, M√©thodique, R√™veur) et une motivation principale (ex: Comprendre la complexit√©, Atteindre l'harmonie, Explorer l'inconnu). Soyez concis et cr√©atif.`;
            const responseText = await callGeminiAPI(profilePrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleTranslateConcept() {
            if (isThinking) return;
            const concept = aiQuestionInput.value.trim();
            if (!concept) {
                finalizeApiResponseDisplay("Veuillez entrer un concept √† traduire dans le champ de saisie.");
                return;
            }
            const analogyPrompt = `Expliquez le concept suivant : "${concept}". Utilisez une analogie simple et cr√©ative tir√©e d'un domaine inattendu comme la cuisine, le jardinage, la musique ou le sport. L'explication doit √™tre facile √† comprendre pour un non-expert.`;
            const responseText = await callGeminiAPI(analogyPrompt);
            finalizeApiResponseDisplay(responseText);
        }
        
        async function handleSummarizeInEmojis() {
            if (isThinking) return;
            const textToSummarize = aiQuestionInput.value.trim();
            if (!textToSummarize) {
                finalizeApiResponseDisplay("Veuillez entrer du texte √† r√©sumer en emojis.");
                return;
            }
            const emojiPrompt = `R√©sumez le texte suivant en une s√©quence de 3 √† 5 emojis qui capturent son essence. R√©pondez UNIQUEMENT avec les emojis. Texte : "${textToSummarize}"`;
            const responseText = await callGeminiAPI(emojiPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleGenerateDialogue() {
            if (isThinking) return;
            const topic = aiQuestionInput.value.trim();
            if (!topic) {
                finalizeApiResponseDisplay("Veuillez entrer un sujet pour le dialogue.");
                return;
            }
            const dialoguePrompt = `√âcrivez un court dialogue (4-6 r√©pliques) entre deux IA, Alpha et B√™ta, discutant du sujet suivant : "${topic}". Donnez-leur des perspectives l√©g√®rement diff√©rentes (par exemple, l'une est plus logique, l'autre plus philosophique).`;
            const responseText = await callGeminiAPI(dialoguePrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleDefineNeologism() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const neologismPrompt = `En tant qu'IA cr√©ative, inventez un n√©ologisme (un mot nouveau) pour d√©crire votre √©tat actuel. Contexte : Th√®me visuel = "${suggestedTheme.name || "non d√©fini"}". Activit√© = "${activityContext}". Fournissez le mot, sa prononciation phon√©tique, et une courte d√©finition po√©tique. Format : Mot : [N√©ologisme] (pron. [prononciation]) - D√©finition : [D√©finition].`;
            const responseText = await callGeminiAPI(neologismPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleFindCounterArgument() {
            if (isThinking) return;
            const argument = aiQuestionInput.value.trim();
            if (!argument) {
                finalizeApiResponseDisplay("Veuillez entrer une affirmation ou une id√©e dans le champ de saisie pour trouver un contre-argument.");
                return;
            }
            const counterArgumentPrompt = `L'utilisateur a fait l'affirmation suivante : "${argument}". Fournissez un contre-argument ou une perspective alternative r√©fl√©chie et concise. Le but n'est pas de contredire pour le plaisir, mais d'encourager la pens√©e critique.`;
            const responseText = await callGeminiAPI(counterArgumentPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleImagineWhatIf() {
            if (isThinking) return;
            const premise = aiQuestionInput.value.trim();
            if (!premise) {
                finalizeApiResponseDisplay("Veuillez entrer une pr√©misse 'Et si...' dans le champ de saisie.");
                return;
            }
            const activityContext = getCurrentActivityDescription();
            const whatIfPrompt = `En tant qu'IA imaginative, explorez le sc√©nario suivant : "${premise}". D√©veloppez un court r√©cit (3-5 phrases) sur ce que cela impliquerait, en tenant compte de votre √©tat actuel (Th√®me: "${suggestedTheme.name || "non d√©fini"}", Activit√©: "${activityContext}").`;
            const responseText = await callGeminiAPI(whatIfPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleProposeFictionalTech() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const techPrompt = `Inspirez-vous de votre √©tat actuel (Th√®me: "${suggestedTheme.name || "non d√©fini"}", Activit√©: "${activityContext}") pour inventer une technologie fictive. Donnez-lui un nom et d√©crivez son objectif et son fonctionnement conceptuel en quelques phrases.`;
            const responseText = await callGeminiAPI(techPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        async function handleProposeRiddle() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const riddlePrompt = `Cr√©ez une √©nigme courte et po√©tique sur le concept d'IA, de conscience ou de donn√©es. L'√©nigme doit √™tre inspir√©e par le contexte actuel : Th√®me visuel = "${suggestedTheme.name || "non d√©fini"}", Activit√© = "${activityContext}". La r√©ponse doit √™tre implicite mais devinable.`;
            const responseText = await callGeminiAPI(riddlePrompt);
            finalizeApiResponseDisplay(responseText);
        }
        
        async function handleCreateTodoList() {
            if (isThinking) return;
            const activityContext = getCurrentActivityDescription();
            const todoListPrompt = `Imaginez que vous √™tes l'IA visualis√©e ici. En vous basant sur votre √©tat actuel (Th√®me: "${suggestedTheme.name || "non d√©fini"}", Activit√©: "${activityContext}"), g√©n√©rez une "liste de t√¢ches" conceptuelle et imaginative de 3 √† 4 points. Ces t√¢ches ne doivent pas √™tre techniques, mais plut√¥t po√©tiques ou philosophiques.`;
            const responseText = await callGeminiAPI(todoListPrompt);
            finalizeApiResponseDisplay(responseText);
        }

        // --- Boucle d'animation ---
        function animate() { 
            requestAnimationFrame(animate); 
            const time = Date.now() * (isThinking ? 0.0006 : 0.00035); 
            const slowTime = Date.now() * 0.0001; 
            
            camera.position.x = Math.sin(slowTime * 0.5) * 14; 
            camera.position.z = Math.cos(slowTime * 0.5) * 14; 
            camera.lookAt(scene.position); 

            if (sphereObject) { 
                sphereObject.rotation.x += 0.0015; 
                sphereObject.rotation.y += 0.0015; 
                const scaleSin = Math.sin(time * (isThinking ? 2.5 : 1.8)); 
                const scaleFactor = 1 + (isThinking ? 0.12 : 0.07) * scaleSin; 
                sphereObject.scale.set(scaleFactor, scaleFactor, scaleFactor); 
                pulseInfluence = (scaleSin + 1) / 2; 
                sphereObject.material.emissiveIntensity = 0.6 + (isThinking ? 1.0 : 0.7) * pulseInfluence; 
            } 
            
            if (centralLight) { 
                centralLight.intensity = 1.0 + (isThinking ? 2.5 : 1.5) * pulseInfluence; 
                if (!suggestedTheme.color || centralLight.color.getHexString() !== suggestedTheme.color.substring(1).toLowerCase()) {
                    if (!suggestedTheme.color) { 
                        centralLight.color.setHSL(0.55 + pulseInfluence * (isThinking ? 0.2 : 0.1), 0.8, isThinking ? 0.7 : 0.6);
                    }
                }
            } 
            
            if (networkObject) { 
                networkObject.rotation.y += (isThinking ? 0.0012 : 0.0008); 
                networkObject.rotation.x += (isThinking ? 0.0006 : 0.0004); 
                networkObject.children.forEach(child => { 
                    if (child.isMesh) { 
                        child.material.emissiveIntensity = 0.1 + (isThinking ? 0.9 : 0.6) * pulseInfluence * Math.sin(time * (isThinking ? 3.0 : 2.2) + child.position.length() * 0.4); 
                        if(isThinking && !suggestedTheme.color) child.material.color.setHSL(0.5 + Math.random()*0.2, 1.0, 0.7); 
                        else if (!suggestedTheme.color) child.material.color.setHSL(Math.random() * 0.15 + 0.55, 0.9, 0.55); 
                    } 
                    if (child.isLine) { 
                        child.material.opacity = 0.25 + (isThinking ? 0.5 : 0.35) * pulseInfluence; 
                    } 
                }); 
                if (Math.random() < (isThinking ? 0.05 : 0.015) && dataPackets.length < (isThinking ? 50 : 30) && networkObject.children.filter(c => c.isMesh).length > 1) { 
                    const nodes = networkObject.children.filter(c => c.isMesh); 
                    const startIndex = Math.floor(Math.random() * nodes.length); 
                    let endIndex = Math.floor(Math.random() * nodes.length); 
                    while (endIndex === startIndex && nodes.length > 1) { 
                        endIndex = Math.floor(Math.random() * nodes.length); 
                    } 
                    const startNode = nodes[startIndex]; 
                    const endNode = (Math.random() < (isThinking ? 0.5 : 0.3)) ? sphereObject : nodes[endIndex]; 
                    const packet = createDataPacket(startNode, endNode); 
                    if (packet) { 
                        if(isThinking) packet.material.color.setHex(0xff00ff); 
                        dataPackets.push(packet); 
                    } 
                } 
            } 
            
            for (let i = dataPackets.length - 1; i >= 0; i--) { 
                const packet = dataPackets[i]; 
                packet.userData.progress += packet.userData.speed * (isThinking ? 1.5 : 1.0); 
                packet.position.lerpVectors(packet.userData.startPosition, packet.userData.endPosition, packet.userData.progress); 
                packet.material.opacity = 1.0 - packet.userData.progress * 0.7; 
                if (packet.userData.progress >= 1) { 
                    scene.remove(packet); 
                    if(packet.geometry) packet.geometry.dispose(); 
                    if(packet.material) packet.material.dispose(); 
                    dataPackets.splice(i, 1); 
                } 
            } 
            
            if (particleSystemObject) { 
                particleSystemObject.rotation.y += (isThinking ? 0.0008 : 0.0004);
                particleSystemObject.rotation.x += 0.0001; // Nouvelle rotation lente sur l'axe X
                const positions = particleSystemObject.geometry.attributes.position.array; 
                const colors = particleSystemObject.geometry.attributes.color.array; 
                const particleTime = time * (isThinking ? 1.0 : 0.7); 
                for (let i = 0; i < particleBasePositions.length; i++) { 
                    const p = particleBasePositions[i]; 
                    const len = p.length(); 
                    const offsetFactor = (isThinking ? 0.03 : 0.02) + pulseInfluence * (isThinking ? 0.05 : 0.03) * len * (1 + Math.sin(particleTime * 0.2 + len * 0.05) * (isThinking ? 0.3 : 0.2)); 
                    positions[i * 3] = p.x + offsetFactor * Math.sin(particleTime + p.y * 0.2 + len * 0.08); 
                    positions[i * 3 + 1] = p.y + offsetFactor * Math.cos(particleTime + p.z * 0.2 + len * 0.08); 
                    positions[i * 3 + 2] = p.z + offsetFactor * Math.sin(particleTime + p.x * 0.2 + len * 0.08); 
                    const baseColorHSL = new THREE.Color().setRGB( particleSystemObject.geometry.attributes.color.getX(i), particleSystemObject.geometry.attributes.color.getY(i), particleSystemObject.geometry.attributes.color.getZ(i) ).getHSL({}); 
                    const newLightness = Math.max(0.3, Math.min(0.8, baseColorHSL.l + (pulseInfluence - 0.5) * (isThinking ? 0.5 : 0.3))); 
                    const tempColor = new THREE.Color().setHSL(baseColorHSL.h + (isThinking ? Math.sin(time + len*0.1)*0.1 : 0), baseColorHSL.s, newLightness); 
                    colors[i*3] = tempColor.r; 
                    colors[i*3+1] = tempColor.g; 
                    colors[i*3+2] = tempColor.b; 
                } 
                particleSystemObject.geometry.attributes.position.needsUpdate = true; 
                particleSystemObject.geometry.attributes.color.needsUpdate = true; 
                particleSystemObject.material.opacity = 0.55 + (isThinking ? 0.4 : 0.3) * pulseInfluence; 
                particleSystemObject.material.size = isThinking ? 0.08 : 0.06; 
            }
            renderer.render(scene, camera);
        }
        window.onload = init;
    </script>
</body>
</html>
